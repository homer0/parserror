<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl">
  <title data-ice="title">Home | parserror</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Parse errors and generate more human messages"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="parserror"><meta property="twitter:description" content="Parse errors and generate more human messages"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/homer0/parserror"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/caseParser.js~CaseParser.html">CaseParser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/errorCase.js~ErrorCase.html">ErrorCase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/formattedError.js~FormattedError.html">FormattedError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/parserror.js~Parserror.html">Parserror</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/scope.js~Scope.html">Scope</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CaseParserType">CaseParserType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ErrorCaseDefinition">ErrorCaseDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ErrorCaseOptions">ErrorCaseOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ParserrorOptions">ParserrorOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ParserrorParseOptions">ParserrorParseOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ParserrorWrapper">ParserrorWrapper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">Class</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><div data-ice="index" class="github-markdown"><h1 id="parserror">Parserror</h1><p><a href="https://travis-ci.org/homer0/parserror"><img src="https://img.shields.io/travis/homer0/parserror.svg?style=flat-square" alt="Travis"></a>
<a href="https://coveralls.io/github/homer0/parserror?branch=master"><img src="https://img.shields.io/coveralls/github/homer0/parserror.svg?style=flat-square" alt="Coveralls github"></a>
<a href="https://david-dm.org/homer0/parserror"><img src="https://img.shields.io/david/homer0/parserror.svg?style=flat-square" alt="David"></a>
<a href="https://david-dm.org/homer0/parserror"><img src="https://img.shields.io/david/dev/homer0/parserror.svg?style=flat-square" alt="David"></a></p>
<p>Parse errors and generate more human messages</p>
<h2 id="introduction">Introduction</h2><blockquote>
<p>If you are wondering why I built this, go to the <a href="#motivation">Motivation</a> section.</p>
</blockquote>
<p>Parserror allows you parse errors from external resources by defining simple (or complex) cases in order to be able to use them in the context of your project:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">const Parserror = require(&apos;parserror&apos;);

// Define the cases
const parserror = Parserror
.new()
.addCases([
  {
    // A simple name to use as reference.
    name: &apos;duplicatedEmail&apos;,
    // An expression the error message must match.
    condition: /email_address already exists/i,
    // A new, more human friendly, error message for your project to use.
    message: &apos;This email address is already in use, please choose another&apos;,
  }
]);

// Use the case

try {
  await registerUser();
} catch (error) {
  // Send the received error to the parser.
  const formatted = parserror.parse(error);
  // Get a new error with the formatted message.
  showNotification(formatted.message);
}</code>
</code></pre>
<h2 id="usage">Usage</h2><h3 id="cases">Cases</h3><p>As demonstrated in the introduction&apos;s example, the way you match and parse your errors is by defining &quot;cases&quot;.</p>
<p>You add new cases using the <code>addCases</code> method, and they can be as simple as the one we already saw, with a basic condition and a <code>string</code> message, or they can be a little more complex.</p>
<h4 id="using-specific-cases">Using specific cases</h4><p>The reason cases have a name is that when you call <code>parse</code>, you can specify a limited list of cases that you want to use for an error.</p>
<p>Keeping with the example from above:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">try {
  await registerUser();
} catch (error) {
  // Send the received error to the parser.
  const formatted = parserror.parse(error, {
    // You can the cases list on the options parameter.
    cases: [&apos;duplicatedEmail&apos;],
  });
  // Get a new error with the formatted message.
  showNotification(formatted.message);
}</code>
</code></pre>
<p>Then, no matter how many cases you have, the error will validate only against the <code>duplicatedEmail</code> case.</p>
<h4 id="case-parameters">Case parameters</h4><p>Let&apos;s say you have an error that is triggered when you send a <code>string</code> with more than <code>300</code> characters, and this is what the message says:</p>
<pre><code><code class="source-code prettyprint">Invalid message: the text exceeds the limit of 300</code>
</code></pre><blockquote>
<p>Yes, I&apos;m using pretty horrible errors to show my point.</p>
</blockquote>
<p>You could extract the <code>300</code> from there so it can be used on the formatted message:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">{
  name: &apos;messageLimitValidation&apos;,
  condition: /Invalid message: the text exceeds the limit of (\d+)/i,
  message: (limit) =&gt; `Your message can&apos;t exceeds the ${limit} characters`,
}</code>
</code></pre>
<p>You just need to use a group on your expression. If the library detects that you have groups, it will use <code>message</code> as a <code>function</code> and send the group as parameters in the order they were found.</p>
<h4 id="case-parsers">Case parsers</h4><p>But what if you want to transformed and extracted parameter before using it your message? Well, that&apos;s what the parsers are for.</p>
<p>Let&apos;s say you have a library that performs image optimization, it has a size limit of 1mb for the files it can handle and you send a ~3.5MB photo, you could get something like this:</p>
<pre><code><code class="source-code prettyprint">Size Violation - The file is to large (3584KB)</code>
</code></pre><p>You could use a parser to make that value into MB:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">{
  name: &apos;fileLimitValidation&apos;,
  condition: /Size Violation - The file is to large \((\d+)\w+\)/i,
  parse: [(size) =&gt; prettysize(size)],
  message: (size) =&gt; `Your image is too big (${size})`,
}</code>
</code></pre>
<p>You can use the <code>parse</code> property to send functions that will allow you to transform the parameters before using them on the <code>message</code>. The order of the list is the same as the parameters.</p>
<p>And you can also use multiple parsers for the same parameters, just use and <code>array</code>:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">{
  name: &apos;fileLimitValidation&apos;,
  condition: /Size Violation - The file is to large \((\d+)\w+\)/i,
  parse: [Number, (size) =&gt; prettysize(size)],
  message: (size) =&gt; `Your image is too big (${size})`,
}</code>
</code></pre>
<p>In this case, before getting to the <code>prettysize</code> parameter, <code>Number</code> will act as a parser and transform the value into a proper number (as values extracted from expressions are always <code>string</code>).</p>
<h5 id="reusable-parsers">Reusable parsers</h5><p>But that&apos;s not all parsers can do; Let&apos;s say the error also shows the limit:</p>
<pre><code><code class="source-code prettyprint">Size Violation - The file is to large (3584KB) - limit is 1024KB</code>
</code></pre><p>And you want to extract and format both sizes for your message, you can define reusable parsers:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">{
  name: &apos;fileLimitValidation&apos;,
  condition: /Size Violation - The file is to large \((\d+)\w+\) - limit is (\d+)\w+/i,
  parsers: {
    sizeParser: (size) =&gt; prettysize(Number(size)),
  },
  parse: [&apos;sizeParser&apos;, &apos;sizeParser&apos;],
  message: (size, limit) =&gt; `Your image is too big: ${size} - The limit size is ${limit}`,
}</code>
</code></pre>
<p>You can define an object on the <code>parsers</code> property with named parsers, that you can later reference on the <code>parse</code> list.</p>
<h5 id="map-parsers">Map parsers</h5><p>Finally, the last &quot;feature&quot; here is that, instead of defining a function, you can also define an &quot;object map&quot; to match with the value of a parameter.</p>
<p>Everything is easier with an example!</p>
<p>Let&apos;s imagine a form to create products, with fields for name, description, price; and on the service you are using save the data, each field has specific rules to validate invalid characters: The name and the description can&apos;t have special symbols, just regular text, and the price can only have numbers.</p>
<p>Then, the fields on the service are called <code>product_name</code>, <code>product_description</code> and <code>product_price</code>, so it&apos;s not uncommon that you&apos;ll get errors like this:</p>
<pre><code><code class="source-code prettyprint">Validation Error: product_description has invalid characters</code>
</code></pre><p>Yes, if you paid attention, you could use a parameter for the name and parser function to map it to a name the end user will understand (like <code>product_description</code> to <code>description</code>).</p>
<p>Well, you could do that, or you can create a simple map parser:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">{
  name: &apos;charactersValidation&apos;,
  condition: /Validation Error: (\w+) has invalid characters/i,
  parsers: {
    fieldParser: {
      &apos;product_name&apos;: {
        label: &apos;product\&apos;s name&apos;,
        field: &apos;input_name&apos;,
      },
      &apos;product_description&apos;: {
        label: &apos;product\&apos;s description&apos;,
        field: &apos;input_description&apos;,
      },
      &apos;product_price&apos;: {
        label: &apos;product\&apos;s price&apos;,
        field: &apos;input_price&apos;,
      }
    }
  },
  parse: [&apos;fieldParser&apos;],
  message: (property) =&gt; `The ${property.label} has invalid characters`,
};</code>
</code></pre>
<p>And if you are wondering what are the <code>field</code> properties for, there&apos;s a &quot;sub feature&quot; here: all parameters are saved on a <code>parameters</code> property, so you could use the map to store metadata that you can later use. For this case, imagine that <code>field</code> could be the name of the UI controller you want to highlight for the user to identify where the error is:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">try {
  await saveProduct();
} catch (error) {
  // Send the received error to the parser.
  const formatted = parserror.parse(error);
  // Get a new error with the formatted message.
  showNotification(formatted.message);

  // Extract the formatted parameter metadata.
  const [property] = formatted.parameters;
  highlightUIController(property.field);
}</code>
</code></pre>
<h3 id="scopes">Scopes</h3><p>By default, when you add cases, they are added to a &quot;global scope&quot;, so they are all available every time you call <code>parse</code>. This &quot;global scope&quot; is automatically created when Parserror is instantiated.</p>
<p>Scopes are groups of cases and parsers that you can use to limit the number of cases that parse an error, and to share reusable parsers between different cases.</p>
<p>There are three ways you can create a scope:</p>
<p>1 - With <code>addScope</code>:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">const parserror = Parserror
.new()
.addScope(&apos;userValidationScope&apos;, [
  {
    name: &apos;duplicatedEmail&apos;,
    condition: /email_address already exists/i,
    message: &apos;This email address is already in use, please choose another&apos;,
  }
]);</code>
</code></pre>
<p>2 - With <code>addCase</code>/<code>addCases</code>:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">const parserror = Parserror
.new()
.addCase(
  {
    name: &apos;duplicatedEmail&apos;,
    condition: /email_address already exists/i,
    message: &apos;This email address is already in use, please choose another&apos;,
  },
  &apos;userValidationScope&apos;
);</code>
</code></pre>
<p>You just send it as a second parameter, and if the scope doesn&apos;t exist, it will be created.</p>
<p>3 - As a property of a case definition:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">const parserror = Parserror
.new()
.addCase({
  name: &apos;duplicatedEmail&apos;,
  condition: /email_address already exists/i,
  message: &apos;This email address is already in use, please choose another&apos;,
  scope: &apos;userValidationScope&apos;,
});</code>
</code></pre>
<p>And yes, this works for both <code>addCase</code> and <code>addCases</code>.</p>
<h4 id="using-scopes">Using scopes</h4><p>Once you have your scopes defined, you can specify them when you call <code>parse</code>:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">try {
  await saveProduct();
} catch (error) {
  // Send the received error to the parser.
  const formatted = parserror.parse(error, {
    // You can the scopes list on the options parameter.
    scopes: [&apos;userValidationScope&apos;],
  });
  // Get a new error with the formatted message.
  showNotification(formatted.message);
}</code>
</code></pre>
<p>In this case, Parserror will try to match against the cases of <code>userValidationScope</code> before trying with the global scope.</p>
<h4 id="scope-parsers">Scope parsers</h4><p>On the parsers section we saw that we can define a reusable parser inside a case definition, but Parserror also allows you to define a parser on a scope and reuse it across multiple cases:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">const parserror = Parserror
.new()
.addParser(&apos;sizeParser&apos;, (size) =&gt; prettysize(Number(size))
.addCases([
  {
    name: &apos;fileLimitValidation&apos;,
    condition: /Size Violation - The file is to large \((\d+)\w+\) - limit is (\d+)\w+/i,
    parse: [&apos;sizeParser&apos;, &apos;sizeParser&apos;],
    message: (size, limit) =&gt; `Your image is too big: ${size} - The limit size is ${limit}`,
  },
  {
    name: &apos;compressionValidation&apos;,
    condition: /The file size is to big to be compressed, the limit is \(\d+)\w+/i,
    parse: [&apos;sizeParser&apos;],
    message: (limit) =&gt; `You can&apos;t compress a file over ${limit}`,
  },
]);</code>
</code></pre>
<p>We first added the parser to the global scope and then we just referenced it from the cases, that&apos;s all.</p>
<p>A few things you should know:</p>
<ul>
<li>The example uses the global scope, but you can achieve the same for a custom scope by using the <code>scope</code> parameter on <code>addParser</code> and <code>addCase</code>/<code>addCases</code>.</li>
<li>If you add the case to a custom scope, you can still reference parsers from the global scope, as Parserror automatically adds the global scope as the last item of the list of scopes to use.</li>
</ul>
<h3 id="wrappers">Wrappers</h3><p>Wrappers are little helpers that allow you to create functions with scopes and/or cases already pre configured:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">const parserror = Parserror
.new()
.addCases([
  {
    name: &apos;duplicatedEmail&apos;,
    condition: /email_address already exists/i,
    message: &apos;This email address is already in use, please choose another&apos;,
  },
  ...
);

const formatUserErrors = parserror.wrap([&apos;duplicatedEmail&apos;, ...]);

...

try {
  await saveProduct();
} catch (error) {
  // Send the received error to the wrapper.
  const formatted = formatUserErrors(error);
  // Get a new error with the formatted message.
  showNotification(formatted.message);
}</code>
</code></pre>
<p>You can also create a wrapper for a scope or a list of them:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">const formatUserErrors = parserror.wrap([], [&apos;userValidationScope&apos;]);</code>
</code></pre>
<p>The only thing weird there is that if you are not using cases, having to define an empty array as first parameter doesn&apos;t look very nice... so you could just use <code>wrapForScopes</code>:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">const formatUserErrors = parserror.wrapForScopes([&apos;userValidationScope&apos;]);</code>
</code></pre>
<h2 id="development">Development</h2><h3 id="npm-yarn-tasks">NPM/Yarn tasks</h3><table>
<thead>
<tr>
<th>Task</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>test</code></td>
<td>Run the project unit tests.</td>
</tr>
<tr>
<td><code>lint</code></td>
<td>Lint the modified files.</td>
</tr>
<tr>
<td><code>lint:all</code></td>
<td>Lint the entire project code.</td>
</tr>
<tr>
<td><code>docs</code></td>
<td>Generate the project documentation.</td>
</tr>
<tr>
<td><code>todo</code></td>
<td>List all the pending to-do&apos;s.</td>
</tr>
</tbody>
</table>
<h3 id="repository-hooks">Repository hooks</h3><p>I use <a href="https://yarnpkg.com/en/package/husky">husky</a> to automatically install the repository hooks so the code will be tested and linted before any commit and the dependencies updated after every merge. The configuration is on the <code>husky</code> property of the <code>package.json</code> and the hooks&apos; files are on <code>./utils/hooks</code>.</p>
<h3 id="testing">Testing</h3><p>I use <a href="https://facebook.github.io/jest/">Jest</a> with <a href="https://yarnpkg.com/en/package/jest-ex">Jest-Ex</a> to test the project. The configuration file is on <code>./.jestrc.json</code>, the tests are on <code>./tests</code> and the script that runs it is on <code>./utils/scripts/test</code>.</p>
<h3 id="linting">Linting</h3><p>I use <a href="http://eslint.org">ESlint</a> with <a href="http://yarnpkg.com/en/package/eslint-plugin-homer0">my own custom configuration</a> to validate all the JS code. The configuration file for the project code is on <code>./.eslintrc</code> and the one for the tests is on <code>./tests/.eslintrc</code>. There&apos;s also an <code>./.eslintignore</code> to exclude some files on the process. The script that runs it is on <code>./utils/scripts/lint</code>.</p>
<h3 id="documentation">Documentation</h3><p>I use <a href="http://esdoc.org">ESDoc</a> to generate HTML documentation for the project. The configuration file is on <code>./.esdoc.json</code> and the script that runs it is on <code>./utils/scripts/docs</code>.</p>
<h3 id="to-dos">To-Dos</h3><p>I use <code>@todo</code> comments to write all the pending improvements and fixes, and <a href="https://yarnpkg.com/en/package/leasot">Leasot</a> to generate a report. The script that runs it is on <code>./utils/scripts/todo</code>.</p>
<h2 id="motivation">Motivation</h2><blockquote>
<p>I put this at the end because no one usually reads it :P.</p>
</blockquote>
<p>Nowadays it&apos;s pretty common to be working with APIs/services/libraries (we&apos;ll call them &quot;resources&quot;) external to your projects, and those resources are <strong>almost never</strong> aware of what kind of project you are building, so whenever they throw/emit errors, they lack context.</p>
<p>Errors without context are hard to handle, most of the times you just can&apos;t just show them to the end user, whether the resource is a library or an API, errors tend to be specific to the its own context.</p>
<p>For example:</p>
<p>Let&apos;s say you have a web app that connects to an API that manages users. You create a UI with a form to enter a new user and email address; on the other side, the API implements some sort of ORM with out-of-the-box validations and the email address is a unique field.</p>
<p>When the user submits the form with an email that is already being used, the API may respond with something like this:</p>
<pre><code><code class="source-code prettyprint">The field &apos;email&apos; must be unique</code>
</code></pre><p>What do you do?</p>
<ol>
<li>Do you show that error to the user?</li>
<li>Check if the error matches against a <code>RegExp</code> or a <code>string</code> in order to rewrite it for the user?</li>
<li>If you have control of the API, do you get rid of the validations in order to write better errors?</li>
</ol>
<p>My answers are:</p>
<ol>
<li>No</li>
<li>That won&apos;t scale if I have a lot of errors to parse.</li>
<li>Even if that were the case, &quot;no, thanks&quot;.</li>
</ol>
<blockquote>
<p>If you have other answers, this library may not be of interest to you.</p>
</blockquote>
<p>Ok, so there weren&apos;t other alternatives, so I took the &quot;possible solution&quot; I could have more control over and created a library that would help me handle it on a more simple and organized way.</p>
</div>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
