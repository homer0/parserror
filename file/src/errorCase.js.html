<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/errorCase.js | parserror</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Parse errors and generate more human messages"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="parserror"><meta property="twitter:description" content="Parse errors and generate more human messages"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/homer0/parserror"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/caseParser.js~CaseParser.html">CaseParser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/errorCase.js~ErrorCase.html">ErrorCase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/formattedError.js~FormattedError.html">FormattedError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/parserror.js~Parserror.html">Parserror</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/scope.js~Scope.html">Scope</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CaseParserType">CaseParserType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ErrorCaseDefinition">ErrorCaseDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ErrorCaseOptions">ErrorCaseOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ParserrorOptions">ParserrorOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ParserrorParseOptions">ParserrorParseOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ParserrorWrapper">ParserrorWrapper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">Class</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/errorCase.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">const Utils = require(&apos;./utils&apos;);
const CaseParser = require(&apos;./caseParser&apos;);
const FormattedError = require(&apos;./formattedError&apos;);

/**
 * @type {function} ErrorCaseMessage
 * @description A function that generates a formatted message for an error.
 * @return {String}
 */

/**
 * @typedef {Object} ErrorCaseDefinition
 * @description The required properties to create a new {@link ErrorCase}.
 * @property {String}                     name      The name of the case.
 * @property {ErrorCaseDefinition|String} message   The formatted message or the `function` that
 *                                                  generates one.
 * @property {RegExp|String}              condition A `string` or a expression to match against an
 *                                                  error that could be parsed.
 * @property {?Object}                    parsers   A map of reusable parsers. Each parser can be
 *                                                  an `object` map, a `function` or an instance of
 *                                                  {@link CaseParser}.
 * @property {?Array}                     parse     A list of parsers the case should use on
 *                                                  extracted parameters. Each item of the list can
 *                                                  be either the name of a parser defined on
 *                                                  `parsers`, the name of a parser on the scope,
 *                                                  a `function` to parse a value, or an `array` of
 *                                                  all the thing previously mentioned.
 */

/**
 * @typedef {Object} ErrorCaseOptions
 * @description The options to customize how the class behaves.
 * @property {Class&lt;CaseParser&gt;}     CaseParserClass     The class to be used to create a parser.
 * @property {Class&lt;FormattedError&gt;} FormattedErrorClass The class to be used to create a custom
 *                                                       error after a message is parsed.
 */

/**
 * The core object of Parserror. A case is like a &quot;service&quot; that validates if an error message
 * matches its `condition` and, if defined, runs multiple parsers in order to generate a new
 * error.
 */
class ErrorCase {
  /**
   * @param {ErrorCaseDefinition} definition   The case definition settings.
   * @param {ErrorCaseOptions}    [options={}] The options to customize how the class behaves.
   * @throws {Error}     If the definition is missing the `name`, the `condition` or the `message`.
   * @throws {TypeError} If the definition `message` is not a string nor a function.
   * @throws {TypeError} If the definition `condition` is not a RegExp nor a string.
   * @throws {TypeError} If the definition includes `parsers` and it&apos;s not an object.
   * @throws {TypeError} If a parser is not an object, a function or an instance of
   *                     {@link CaseParserClass}.
   * @throws {TypeError} If the definition includes `parse` and it&apos;s not an `array` nor an object.
   * @throws {TypeError} If the definition includes `parse` and an item is not an `array`, a
   *                     function or an object.
   */
  constructor(definition, options = {}) {
    /**
     * The options to customize how the class behaves.
     * @type {ErrorCaseOptions}
     * @access protected
     * @ignore
     */
    this._options = Object.assign(
      {
        CaseParserClass: CaseParser,
        FormattedErrorClass: FormattedError,
      },
      options
    );

    this._validateMissingProperties(definition);
    /**
     * The case name.
     * @type {String}
     * @access protected
     * @ignore
     */
    this._name = this._validateName(definition.name);
    /**
     * The function that generates the formatted message.
     * @type {ErrorCaseMessage}
     * @access protected
     * @ignore
     */
    this._message = this._validateMessage(definition.message);
    /**
     * The expression to validate if an error matches the case.
     * @type {RegExp}
     * @access protected
     * @ignore
     */
    this._condition = this._validateCondition(definition.condition);
    /**
     * An object with all the parsers the case can make use of.
     * @type {Object}
     * @access protected
     * @ignore
     */
    this._parsers = this._validateParsers(definition.parsers);
    /**
     * A list of the parse instructions the case can use on extracted parameters.
     * @type {Array}
     * @access protected
     * @ignore
     */
    this._parse = this._validateParseInstructions(definition.parse);
    /**
     * A flag to know whether the parse instructions where defined as an object (`true`) or
     * an array (`false`). This is for when the condition uses named groups to extract
     * parameters.
     * @type {Boolean}
     * @access protected
     * @ignore
     */
    this._parseAsGroups = Utils.isObject(this._parse);
  }
  /**
   * Validates an error message against the case condition and if it matches, it parses it in
   * order to return a formatted error.
   * @param {String}       errorMessage   The error message to validate and, possibly, parse.
   * @param {Array&lt;Scope&gt;} [scopes=[]]    A list of scopes from where the case can try to find
   *                                      reusable parsers.
   * @param {?Object}      [context=null] Custom context information about the error that can be
   *                                      sent to the formatted error.
   * @return {?FormattedError} If the condition doesn&apos;t match, it will return `null`.
   * @throws {Error} If the condition matches, parameters are extracted as named groups but the
   *                 case&apos;s `parse` instructions were defined as an array.
   * @throws {Error} If the condition matches, parameters are extracted as a list but the case&apos;s
   *                 `parse` instructions were defined as an object.
   * @throws {Error} If the condition matches, one of the parsers the case wants to use is
   *                 suppoused to be on one of the scopes but it can&apos;t be found.
   * @throws {Error} If the condition has a mix of named and unnamed groups.
   */
  parse(errorMessage, scopes = [], context = null) {
    let result;
    if (errorMessage.match(this._condition)) {
      result = this._parseError(errorMessage, scopes, context);
    } else {
      result = null;
    }

    return result;
  }
  /**
   * The case name.
   * @type {String}
   */
  get name() {
    return this._name;
  }
  /**
   * The actual method that parses an error message once it matches the case condition.
   * @param {String}       errorMessage The error message to validate and, possibly, parse.
   * @param {Array&lt;Scope&gt;} scopes       A list of scopes from where the case can try to find
   *                                    reusable parsers.
   * @param {?Object}      context      Custom context information about the error that can be sent
   *                                    to the formatted error.
   * @return {FormattedError}
   * @throws {Error} If the parameters are extracted as named groups but the case&apos;s `parse`
   *                 instructions were defined as an array.
   * @throws {Error} If the parameters are extracted as a list but the case&apos;s `parse` instructions
   *                 were defined as an object.
   * @throws {Error} If the condition has a mix of named and unnamed groups.
   * @access protected
   * @ignore
   */
  _parseError(errorMessage, scopes, context) {
    let result;
    const extracted = this._extractParameters(errorMessage);
    if (extracted.groups) {
      if (this._parseAsGroups) {
        result = this._parseGroups(extracted.groups, scopes, context);
      } else {
        throw new Error(
          `The condition for the case &apos;${this._name}&apos; returned groups, but the &apos;parse&apos; ` +
          &apos;instructions were set on an \&apos;array\&apos; format&apos;
        );
      }
    } else if (extracted.matches.length) {
      if (this._parseAsGroups) {
        throw new Error(
          `The condition for the case &apos;${this._name}&apos; didn&apos;t return groups, but the &apos;parse&apos; ` +
          &apos;instructions were set on an \&apos;object\&apos; format&apos;
        );
      } else {
        result = this._parseList(extracted.matches, scopes, context);
      }
    } else {
      result = this._createError(this._message(), [], context);
    }

    return result;
  }
  /**
   * Parses named groups extracted from the case condition expression.
   * @param {Object}       groups  The named groups.
   * @param {Array&lt;Scope&gt;} scopes  A list of scopes from where the case can try to find
   *                               reusable parsers.
   * @param {?Object}      context Custom context information about the error that can be sent
   *                               to the formatted error.
   *
   * @return {Object} The new parameters, also named.
   * @access protected
   * @ignore
   */
  _parseGroups(groups, scopes, context) {
    const params = Object.keys(groups).reduce(
      (newParams, name) =&gt; {
        const value = groups[name];
        const parsers = this._parse[name];
        let newValue;
        if (parsers) {
          newValue = parsers.reduce(
            (currentValue, parser) =&gt; this._parseValue(parser, currentValue, scopes),
            value
          );
        } else {
          newValue = value;
        }

        return Object.assign({}, newParams, {
          [name]: newValue,
        });
      },
      {}
    );

    const message = this._message(params);
    return this._createError(message, params, context);
  }
  /**
   * Parses a list of parameters extracted from the case condition expression.
   * @param {Array&lt;String&gt;}  list   The list of parameters to parse.
   * @param {Array&lt;Scope&gt;}   scopes A list of scopes from where the case can try to find
   *                                reusable parsers.
   * @param {?Object}      context  Custom context information about the error that can be sent
   *                                to the formatted error.
   *
   * @return {Array}
   * @access protected
   * @ignore
   */
  _parseList(list, scopes, context) {
    const params = list.map((value, index) =&gt; {
      const parsers = this._parse[index];
      let newValue;
      if (parsers) {
        newValue = parsers.reduce(
          (currentValue, parser) =&gt; this._parseValue(parser, currentValue, scopes),
          value
        );
      } else {
        newValue = value;
      }

      return newValue;
    });

    const message = this._message(...params);
    return this._createError(message, params, context);
  }
  /**
   * Parses a single value using a given parser. The reason this is wrapped in a method is
   * because this functionality is independant of the type of parameters extracted (named or
   * unnamed groups).
   * @param {String|CaseParser} parser The name of a parser the needs to be found on the scopes or
   *                                   an actual parser to format the value.
   * @param {*}                 value  The value to parse.
   * @param {Array&lt;Scope&gt;}      scopes A list of scopes where parsers can be found.
   * @return {*} The parsed value.
   * @throws {Error} If the parser is a `string` and a parser with that name can&apos;t be found in any
   *                 of the scopes.
   * @access protected
   * @ignore
   */
  _parseValue(parser, value, scopes) {
    let result;
    if (typeof parser === &apos;string&apos;) {
      let scopeParser;
      scopes.some((scope) =&gt; {
        scopeParser = scope.getParser(parser, false);
        return scopeParser;
      });

      if (scopeParser) {
        result = scopeParser.parse(value);
      } else {
        throw new Error(
          `No parser with the name of &apos;${parser}&apos; could be found for the ` +
          `case &apos;${this._name}&apos;`
        );
      }
    } else {
      result = parser.parse(value);
    }

    return result;
  }
  /**
   * Creates a new instance of the {@link FormattedError} using the class sent on the case&apos;s
   * `constructor` options.
   * @param {String}       message  The error message.
   * @param {Object|Array} params   The parsed parameters Parserror found. When parsing a
   *                                case that uses named groups, the parameters are stored
   *                                on an `object`; otherwise, they&apos;ll be an `array`.
   * @param {?Object}      context  Any extra context information for the error.
   * @return {FormattedError}
   * @access protected
   * @ignore
   */
  _createError(message, params, context) {
    const { FormattedErrorClass } = this._options;
    return new FormattedErrorClass(message, params, context);
  }
  /**
   * Validates if one on the case&apos;s definition required properties is missing.
   * @param {ErrorCaseDefinition} definition The case definition settings.
   * @throws {Error} If one of the properties is missing.
   * @access protected
   * @ignore
   */
  _validateMissingProperties(definition) {
    const missing = [
      &apos;name&apos;,
      &apos;condition&apos;,
      &apos;message&apos;,
    ]
    .find((property) =&gt; typeof definition[property] === &apos;undefined&apos;);
    if (missing) {
      throw new Error(`The &apos;${missing}&apos; property is required on a case definition`);
    }
  }
  /**
   * Validates that the name the class intends to use is a `string`.
   * @param {String} name The name to validate.
   * @return {String}
   * @throws {TypeError} If the `name` is not a string.
   * @access protected
   * @ignore
   */
  _validateName(name) {
    if (typeof name !== &apos;string&apos;) {
      throw new TypeError(&apos;The \&apos;name\&apos; can only be a \&apos;string\&apos;&apos;);
    }

    return name;
  }
  /**
   * Validates whether something can be used as the case&apos;s message.
   * @param {String|ErrorCaseMessage} message The value intended to be the case&apos;s message.
   * @return {ErrorCaseMessage}
   * @throws {Error} If the message is not a `function` nor a `string`.
   * @access protected
   * @ignore
   */
  _validateMessage(message) {
    let result;
    const type = typeof message;
    if (type === &apos;string&apos;) {
      result = () =&gt; message;
    } else if (type === &apos;function&apos;) {
      result = message;
    } else {
      throw new TypeError(
        `&apos;${this._name}&apos;: &apos;message&apos; can only be a &apos;string&apos; or a &apos;function&apos;`
      );
    }

    return result;
  }
  /**
   * Validates whether something can be used as the case&apos;s condition.
   * @param {String|RegExp} condition The value intended to be the case&apos;s condition.
   * @return {RegExp}
   * @throws {Error} If the condition is not a `string` nor a `RegExp`.
   * @access protected
   * @ignore
   */
  _validateCondition(condition) {
    let result;
    if (typeof condition === &apos;string&apos;) {
      result = new RegExp(Utils.escapeForRegExp(condition));
    } else if (condition instanceof RegExp) {
      result = condition;
    } else {
      throw new TypeError(
        `&apos;${this._name}&apos;: &apos;condition&apos; can only be a &apos;string&apos; or a &apos;RegExp&apos;`
      );
    }

    return result;
  }
  /**
   * Validates a dictionary of parsers so it can be used by the case.
   * @param {?Object} parsers A dictionary of reusable parsers.
   * @return {Object}
   * @throws {Error} If `parsers` is not an object.
   * @throws {Error} If a a value insde a parser is not an instance of {@link CaseParserClass},
   *                 an `object` nor a `function`.
   * @access protected
   * @ignore
   */
  _validateParsers(parsers) {
    let result;
    if (parsers) {
      if (!Utils.isObject(parsers)) {
        throw new TypeError(`&apos;${this._name}&apos;: &apos;parsers&apos; can only be an &apos;object&apos;`);
      }

      const { CaseParserClass } = this._options;
      result = Object.keys(parsers).reduce(
        (newParsers, name) =&gt; Object.assign({}, newParsers, {
          [name]: this._validateParser(name, parsers[name], CaseParserClass),
        }),
        {}
      );
    } else {
      result = {};
    }

    return result;
  }
  /**
   * Validates and normalizes a parser intended to be used in the case.
   * @param {String}                          name             The name of the parser.
   * @param {CaseParserClass|Object|Function} parser           The parser definition.
   * @param {Class&lt;CaseParser&gt;}               CaseParserClass  To compare if the parser definition
   *                                                           is `instaceof`.
   * @return {CaseParserClass}
   * @throws {Error} If the `parser` is not an instance of {@link CaseParserClass}, an `object`
   *                 nor a `function`.
   * @access protected
   * @ignore
   */
  _validateParser(name, parser, CaseParserClass) {
    let result;
    if (parser instanceof CaseParserClass) {
      result = parser;
    } else {
      const isObject = Utils.isObject(parser);
      if (isObject || typeof parser === &apos;function&apos;) {
        result = new CaseParserClass(name, parser);
      } else {
        throw new TypeError(
          `&apos;${this._name}&apos; - &apos;${name}&apos;: a parser can only be a &apos;function&apos; or an &apos;object&apos;`
        );
      }
    }

    return result;
  }
  /**
   * Validates and normalizes the parse instructions for the case.
   * @param {?Array|?Object} parse The list/map of instructions to validate.
   * @return {Array|Object}
   * @throws {Error} If the instructions are not an `array` nor an `object`.
   * @throws {Error} If an instruction is not a `function`, a `string` or an `array`.
   * @access protected
   * @ignore
   */
  _validateParseInstructions(parse) {
    let result;
    if (parse) {
      const { CaseParserClass } = this._options;
      if (Array.isArray(parse)) {
        result = parse.map((instruction, index) =&gt; Utils.ensureArray(
          this._validateParseInstruction(
            `${this._name}-parser-${index}`,
            instruction,
            CaseParserClass
          )
        ));
      } else if (Utils.isObject(parse)) {
        result = Object.keys(parse).reduce(
          (newParse, parameterName) =&gt; Object.assign({}, newParse, {
            [parameterName]: Utils.ensureArray(
              this._validateParseInstruction(
                `${this._name}-parser-${parameterName}`,
                parse[parameterName],
                CaseParserClass
              )
            ),
          }),
          {}
        );
      } else {
        throw new TypeError(
          `&apos;${this._name}&apos;: &apos;parse&apos; can only be an &apos;array&apos; or an &apos;object&apos;`
        );
      }
    } else {
      result = [];
    }

    return result;
  }
  /**
   * Validates and normalizes a single parse instruction.
   * @param {String}                id              The ID of the instruction. Internally generated
   *                                                by the case in order to have some reference
   *                                                for error messages.
   * @param {function|String|Array} instruction     The instruction to validate.
   * @param {Class&lt;CaseParser&gt;}     CaseParserClass The class used to create new parsers. If the
   *                                                instruction is a function, it will be converted
   *                                                into a parser.
   * @return {function|String|Array}
   * @throws {Error} If the instruction is not a `function`, a `string` or an `array`.
   * @access protected
   * @ignore
   */
  _validateParseInstruction(id, instruction, CaseParserClass) {
    let result;
    const type = typeof instruction;
    if (type === &apos;function&apos;) {
      result = new CaseParserClass(id, instruction);
    } else if (type === &apos;string&apos;) {
      if (this._parsers[instruction]) {
        result = this._parsers[instruction];
      } else {
        result = instruction;
      }
    } else if (Array.isArray(instruction)) {
      result = instruction.map((item, index) =&gt; this._validateParseInstruction(
        `${id}-sub-${index}`,
        item,
        CaseParserClass
      ));
    } else {
      throw new TypeError(
        `&apos;${this._name}&apos;: a &apos;parse&apos; instruction can only be ` +
        &apos;an \&apos;array\&apos;, a \&apos;function\&apos; or a \&apos;string\&apos;&apos;
      );
    }

    return result;
  }
  /**
   * Extracts the parameters from an error message using the case condition.
   * @param {String} errorMessage The message from where the parameters will be extracted.
   * @return {Object}           Only one of the properties will be returned
   * @property {?Array} matches If the expression extracted unnamed groups, this will be a list of
   *                            them.
   * @property {?Object} groups If the expression extracted named groups, this will be the
   *                            dictionary with them.
   * @throws {Error} If there&apos;s a mix of named and unnamed groups on the condition.
   * @access protected
   * @ignore
   */
  _extractParameters(errorMessage) {
    const match = Utils.execRegExp(this._condition, errorMessage);
    let result;
    const matches = match.slice().filter((item) =&gt; typeof item !== &apos;undefined&apos;);
    matches.shift();
    if (match.groups) {
      const groups = Object.assign({}, match.groups);
      const groupsLength = Object.keys(groups).length;
      if (groupsLength) {
        if (groupsLength !== matches.length) {
          throw new Error(
            `The condition for the case &apos;${this._name}&apos; is trying to extract parameters as ` +
            &apos;named and unnamed groups, only one method is allowed&apos;
          );
        } else {
          result = { groups };
        }
      } else {
        result = { matches };
      }
    } else {
      result = { matches };
    }

    return result;
  }
}

module.exports = ErrorCase;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
